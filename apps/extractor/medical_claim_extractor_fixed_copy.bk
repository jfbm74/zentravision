import logging
import json
import fitz  # PyMuPDF
from typing import Dict, Any, Optional, List, Tuple
from datetime import datetime
import re
import os
import time

logger = logging.getLogger(__name__)

class MedicalClaimExtractor:
    """
    Extractor optimizado específicamente para glosas SOAT colombianas
    Versión mejorada que maneja procedimientos en múltiples formatos
    Y extrae información adicional para formato Excel IPS
    """
    
    def __init__(self, openai_api_key=None):
        # Si no se proporciona API key, intentar obtenerla del entorno
        if openai_api_key is None:
            openai_api_key = os.environ.get('OPENAI_API_KEY')
            if openai_api_key:
                logger.info("API key de OpenAI cargada desde variables de entorno")
        
        self.openai_api_key = openai_api_key
        self._setup_soat_patterns()

    def _setup_soat_patterns(self):
        """Configura patrones específicos para documentos SOAT"""
        
        # Patrones para información del paciente
        self.patient_patterns = {
            'nombre': [
                r'Víctima\s*:\s*[A-Z]{1,3}\s*-\s*\d+\s*-\s*([A-ZÁÉÍÓÚÑ\s]+?)(?:\n|\r|Número)',
                r'VICTIMA\s*:\s*[A-Z]{1,3}\s*-\s*\d+\s*-\s*([A-ZÁÉÍÓÚÑ\s]+)',
                r'CC\s*-\s*\d+\s*-\s*([A-ZÁÉÍÓÚÑ\s]+?)(?:\n|\r|Número)',
            ],
            'documento': [
                r'Víctima\s*:\s*([A-Z]{1,3})\s*-\s*(\d+)\s*-',
                r'VICTIMA\s*:\s*([A-Z]{1,3})\s*-\s*(\d+)\s*-',
                r'CC\s*-\s*(\d+)\s*-',
                r'TI\s*-\s*(\d+)\s*-',
                r'NIT\s*-\s*(\d+)',
            ],
            'tipo_documento': [
                r'Víctima\s*:\s*([A-Z]{1,3})\s*-',
                r'VICTIMA\s*:\s*([A-Z]{1,3})\s*-',
            ]
        }
        
        # Patrones para información de póliza
        self.policy_patterns = {
            'numero_liquidacion': [
                r'Liquidación\s+de\s+siniestro\s+No\.\s*([A-Z0-9\-]+)',
                r'LIQ-(\d+)',
                r'GNS-LIQ-(\d+)',
            ],
            'poliza': [
                r'Póliza\s*:\s*(\d+)',
                r'POLIZA\s*:\s*(\d+)',
            ],
            'numero_reclamacion': [
                r'Número\s+de\s+reclamación\s*:\s*([A-Z0-9]+)',
                r'reclamación\s*:\s*([A-Z0-9]+)',
            ],
            'fecha_siniestro': [
                r'Fecha\s+de\s+siniestro\s*:\s*(\d{1,2}/\d{1,2}/\d{4})',
                r'siniestro\s*:\s*(\d{1,2}/\d{1,2}/\d{4})',
            ],
            'fecha_ingreso': [
                r'Fecha\s+de\s+ingreso\s*:\s*(\d{1,2}/\d{1,2}/\d{4})',
                r'ingreso\s*:\s*(\d{1,2}/\d{1,2}/\d{4})',
            ],
            'fecha_pago': [
                r'Fecha\s+de\s+Pago\s*:\s*(\d{1,2}/\d{1,2}/\d{4})',
                r'Pago\s*:\s*(\d{1,2}/\d{1,2}/\d{4})',
            ],
            'orden_pago': [
                r'Orden\s+de\s+pago\s*:\s*(\d+)',
                r'pago\s*:\s*(\d+)',
            ]
        }
        
        # Patrones para diagnósticos
        self.diagnostic_patterns = [
            r'DX\s*:\s*([A-Z]\d{2,3})',
            r'DIAGNOSTICO\s*:\s*([A-Z]\d{2,3})',
            r'CIE\s*:\s*([A-Z]\d{2,3})',
        ]
        
        # Patrones financieros
        self.financial_totals_patterns = {
            'valor_reclamacion': [
                r'Valor\s+de\s+Reclamación\s*:\s*\$?([\d,\.]+)',
                r'Total\s+\$?([\d,\.]+)',
                r'TOTAL\s+RECLAMADO\s*:\s*\$?([\d,\.]+)',
            ],
            'valor_objetado': [
                r'Valor\s+objetado\s*:\s*\$?([\d,\.]+)',
                r'VALOR\s+OBJETADO\s*:\s*\$?([\d,\.]+)',
                r'Total\s+objetado\s*:\s*\$?([\d,\.]+)',
            ],
            'valor_pagado': [
                r'Valor\s+pagado\s*:\s*\$?([\d,\.]+)',
                r'VALOR\s+PAGADO\s*:\s*\$?([\d,\.]+)',
                r'Total\s+pagado\s*:\s*\$?([\d,\.]+)',
                r'Valor\s+Pagado\s*:\s*\$?([\d,\.]+)',
            ],
            'valor_nota_credito': [
                r'Valor\s+Nota\s+Crédito\s*:\s*\$?([\d,\.]+)',
                r'NOTA\s+CREDITO\s*:\s*\$?([\d,\.]+)',
            ],
            'valor_impuestos': [
                r'Valor\s+impuestos\s*:\s*\$?([\d,\.]+)',
                r'IMPUESTOS\s*:\s*\$?([\d,\.]+)',
            ]
        }
        
        # Patrones para IPS
        self.ips_patterns = [
            r'Señores\s*:\s*([A-ZÁÉÍÓÚÑ\s\.]+?)(?:\n|\r)',
            r'([A-ZÁÉÍÓÚÑ\s\.]+?)\s+IPS\s+SAS',
            r'([A-ZÁÉÍÓÚÑ\s\.]+?)\s+Departamento\s+de\s+cartera',
        ]

    # ============================================================================
    # MÉTODO PRINCIPAL DE EXTRACCIÓN
    # ============================================================================

    def extract_from_pdf(self, pdf_path: str, strategy: str = 'hybrid') -> Dict[str, Any]:
        """Método principal de extracción con logs detallados"""
        try:
            logger.info(f"=" * 80)
            logger.info(f"Iniciando extracción SOAT con estrategia: {strategy}")
            logger.info(f"Archivo: {pdf_path}")
            logger.info(f"API Key configurada: {'Sí' if self.openai_api_key else 'No'}")
            
            # Extraer texto del PDF
            text_content = self._extract_text_from_pdf(pdf_path)
            
            if not text_content.strip():
                logger.warning("No se pudo extraer texto del PDF")
                return self._get_empty_result()
            
            logger.info(f"Texto extraído exitosamente: {len(text_content)} caracteres")
            
            # Si la estrategia es ai_only, usar SOLO OpenAI
            if strategy == 'ai_only':
                if self.openai_api_key:
                    try:
                        logger.info("Estrategia AI_ONLY: usando solo OpenAI para extracción")
                        logger.info("=" * 60)
                        logger.info("INICIANDO PROCESO DE OPENAI...")
                        ai_result = self._extract_with_openai(text_content)
                        
                        if ai_result and ai_result.get('procedures'):
                            logger.info(f"OpenAI completó exitosamente: {len(ai_result.get('procedures', []))} procedimientos encontrados")
                            
                            # Log detallado de procedimientos encontrados por OpenAI
                            logger.info("Procedimientos encontrados por OpenAI:")
                            for proc in ai_result.get('procedures', []):
                                logger.info(f"  - {proc.get('codigo', 'SIN CÓDIGO')}: {proc.get('descripcion', '')[:50]}... (${proc.get('valor_total', 0):,.0f})")
                            
                            result = ai_result  # Usar directamente el resultado de AI
                        else:
                            logger.warning("OpenAI no retornó resultados válidos")
                            return self._get_error_result("OpenAI no retornó datos válidos")
                    except Exception as e:
                        logger.error(f"Error con OpenAI: {str(e)}", exc_info=True)
                        return self._get_error_result(f"Error en extracción con IA: {str(e)}")
                else:
                    logger.warning("No hay API key de OpenAI configurada")
                    return self._get_error_result("API key de OpenAI no configurada")
            
            # Para estrategias 'regex_only' o 'hybrid', usar extracción por regex
            else:
                # Usar extracción optimizada
                result = self._extract_soat_data(text_content)
                logger.info(f"Extracción regex completada: {len(result.get('procedures', []))} procedimientos encontrados")
                
                # Si es hybrid, mejorar con IA
                if strategy == 'hybrid' and self.openai_api_key:
                    try:
                        logger.info("=" * 60)
                        logger.info("INICIANDO PROCESO DE OPENAI PARA COMPLEMENTAR...")
                        ai_result = self._extract_with_openai(text_content)
                        
                        if ai_result and ai_result.get('procedures'):
                            logger.info(f"OpenAI encontró {len(ai_result.get('procedures', []))} procedimientos")
                            
                            # En modo hybrid, combinar inteligentemente los resultados
                            result = self._merge_results(result, ai_result)
                            logger.info(f"Después de combinar: {len(result.get('procedures', []))} procedimientos totales")
                        else:
                            logger.warning("OpenAI no retornó resultados válidos para complementar")
                    except Exception as e:
                        logger.error(f"Error con OpenAI en modo hybrid: {str(e)}")
                        # En hybrid, si OpenAI falla, continuamos con los resultados de regex
            
            # Agregar metadata
            result['metadata'] = {
                'extraction_strategy': strategy,
                'extraction_date': datetime.now().isoformat(),
                'file_path': pdf_path,
                'text_length': len(text_content),
                'success': True,
                'document_type': 'SOAT',
                'openai_used': self.openai_api_key is not None and strategy in ['hybrid', 'ai_only']
            }
            
            logger.info(f"=" * 80)
            logger.info(f"Extracción completada exitosamente:")
            logger.info(f"  - Total procedimientos: {len(result.get('procedures', []))} procedimientos")
            logger.info(f"  - Estrategia: {strategy}")
            logger.info(f"  - OpenAI usado: {result['metadata']['openai_used']}")
            logger.info(f"=" * 80)
            
            return result
            
        except Exception as e:
            logger.error(f"Error en extracción: {str(e)}", exc_info=True)
            return self._get_error_result(str(e))

    # ============================================================================
    # EXTRACCIÓN DE PROCEDIMIENTOS MEJORADA
    # ============================================================================

    def _extract_procedures(self, text: str) -> List[Dict[str, Any]]:
        """
        Método principal mejorado para extracción de procedimientos
        Ahora busca procedimientos línea por línea en la tabla
        """
        procedures = []
        seen_keys = set()  # Para evitar duplicados
        
        logger.info("Iniciando extracción exhaustiva de procedimientos")
        
        # Buscar la tabla de procedimientos
        lines = text.split('\n')
        
        # Encontrar donde empieza la tabla de procedimientos
        table_start = -1
        table_end = -1
        
        for i, line in enumerate(lines):
            # Buscar el encabezado de la tabla
            if re.search(r'Código\s+Descripción\s+Cant\s+Valor\s+total', line, re.IGNORECASE):
                table_start = i + 1
                logger.info(f"Tabla de procedimientos encontrada en línea {i}")
                break
        
        if table_start == -1:
            # Si no encontramos encabezado, buscar directamente procedimientos
            for i, line in enumerate(lines):
                if re.match(r'^\d{5}\s+[A-ZÁÉÍÓÚÑ]', line, re.IGNORECASE):
                    table_start = i
                    logger.info(f"Procedimientos encontrados sin encabezado en línea {i}")
                    break
        
        if table_start != -1:
            # Encontrar el final de la tabla
            for i in range(table_start, len(lines)):
                if re.search(r'^Total\s+\$', lines[i], re.IGNORECASE) or \
                   re.search(r'Valor\s+de\s+Reclamación:', lines[i], re.IGNORECASE):
                    table_end = i
                    break
            
            if table_end == -1:
                table_end = len(lines)
            
            logger.info(f"Analizando tabla desde línea {table_start} hasta {table_end}")
            
            # Procesar cada línea de la tabla
            i = table_start
            while i < table_end:
                line = lines[i].strip()
                
                if not line:
                    i += 1
                    continue
                
                # Intentar extraer procedimiento de la línea actual
                procedure = self._extract_procedure_from_line(line, lines, i, table_end)
                
                if procedure:
                    # Crear clave única para evitar duplicados
                    key = f"{procedure['codigo']}_{procedure['descripcion'][:30]}"
                    if key not in seen_keys:
                        procedures.append(procedure)
                        seen_keys.add(key)
                        logger.debug(f"Procedimiento extraído: {procedure['codigo']} - {procedure['descripcion'][:50]}...")
                
                i += 1
        
        # Si no encontramos procedimientos en la tabla, buscar en todo el texto
        if len(procedures) == 0:
            logger.warning("No se encontraron procedimientos en tabla estructurada, buscando en texto completo")
            procedures = self._extract_procedures_from_full_text(text)
        
        logger.info(f"Total procedimientos extraídos: {len(procedures)}")
        return procedures

    def _extract_procedure_from_line(self, line: str, all_lines: List[str], line_idx: int, table_end: int) -> Optional[Dict[str, Any]]:
        """
        Extrae un procedimiento de una línea específica
        Maneja todos los formatos posibles y MEJORA la extracción de observaciones
        """
        # Patrón 1: Línea completa con código de 5 dígitos
        pattern1 = r'^(\d{5})\s+([A-ZÁÉÍÓÚÑ][A-ZÁÉÍÓÚÑ\s\w\/\#\,\.\-\(\)\%]+?)\s+(\d+(?:\.\d+)?)\s+\$?([\d,\.]+)\s+\$?([\d,\.]+)\s+\$?([\d,\.]+)'
        match = re.match(pattern1, line, re.IGNORECASE)
        
        if match:
            codigo = match.group(1).strip()
            descripcion = self._clean_description(match.group(2).strip())
            cantidad = float(match.group(3).strip())
            valor_total = self._parse_money_value(match.group(4))
            valor_pagado = self._parse_money_value(match.group(5))
            valor_objetado = self._parse_money_value(match.group(6))
            
            # Buscar observación en el resto de la línea o líneas siguientes
            observacion = self._extract_observation_from_lines(all_lines, line_idx, table_end)
            
            if self._is_valid_procedure(codigo, descripcion, valor_total):
                return {
                    'codigo': codigo,
                    'descripcion': descripcion,
                    'cantidad': int(cantidad),
                    'valor_unitario': valor_total / cantidad if cantidad > 0 else 0,
                    'valor_total': valor_total,
                    'valor_pagado': valor_pagado,
                    'valor_objetado': valor_objetado,
                    'observacion': observacion,
                    'estado': 'objetado' if valor_objetado > 0 else 'aceptado',
                    'extraction_method': 'table_line'
                }
        
        # Patrón 2: Código compuesto (como 19934768-18)
        pattern_compuesto = r'^(\d{5,8}-\d{1,2})\s+([A-ZÁÉÍÓÚÑ][A-ZÁÉÍÓÚÑ\s\w\/\#\,\.\-\(\)\%]+?)\s+(\d+(?:\.\d+)?)\s+\$?([\d,\.]+)\s+\$?([\d,\.]+)\s+\$?([\d,\.]+)'
        match = re.match(pattern_compuesto, line, re.IGNORECASE)
        
        if match:
            codigo = match.group(1).strip()
            descripcion = self._clean_description(match.group(2).strip())
            cantidad = float(match.group(3).strip())
            valor_total = self._parse_money_value(match.group(4))
            valor_pagado = self._parse_money_value(match.group(5))
            valor_objetado = self._parse_money_value(match.group(6))
            
            # Buscar observación
            observacion = self._extract_observation_from_lines(all_lines, line_idx, table_end)
            
            if self._is_valid_procedure(codigo, descripcion, valor_total):
                return {
                    'codigo': codigo,
                    'descripcion': descripcion,
                    'cantidad': int(cantidad),
                    'valor_unitario': valor_total / cantidad if cantidad > 0 else 0,
                    'valor_total': valor_total,
                    'valor_pagado': valor_pagado,
                    'valor_objetado': valor_objetado,
                    'observacion': observacion,
                    'estado': 'objetado' if valor_objetado > 0 else 'aceptado',
                    'extraction_method': 'table_line_compound'
                }
        
        # Patrón 3: Solo código en la línea
        if re.match(r'^(\d{5})$', line.strip()):
            codigo = line.strip()
            # Buscar descripción y valores en líneas siguientes
            if line_idx + 1 < table_end:
                next_line = all_lines[line_idx + 1].strip()
                # Si la siguiente línea tiene la descripción
                if re.match(r'^[A-ZÁÉÍÓÚÑ]', next_line, re.IGNORECASE):
                    # Intentar extraer todo de las siguientes líneas
                    combined_text = ' '.join([all_lines[j].strip() for j in range(line_idx + 1, min(line_idx + 4, table_end))])
                    
                    # Buscar patrón de descripción + valores
                    desc_pattern = r'^([A-ZÁÉÍÓÚÑ][A-ZÁÉÍÓÚÑ\s\w\/\#\,\.\-\(\)\%]+?)\s+(\d+(?:\.\d+)?)\s+\$?([\d,\.]+)\s+\$?([\d,\.]+)\s+\$?([\d,\.]+)'
                    desc_match = re.match(desc_pattern, combined_text, re.IGNORECASE)
                    
                    if desc_match:
                        descripcion = self._clean_description(desc_match.group(1).strip())
                        cantidad = float(desc_match.group(2).strip())
                        valor_total = self._parse_money_value(desc_match.group(3))
                        valor_pagado = self._parse_money_value(desc_match.group(4))
                        valor_objetado = self._parse_money_value(desc_match.group(5))
                        
                        if self._is_valid_procedure(codigo, descripcion, valor_total):
                            return {
                                'codigo': codigo,
                                'descripcion': descripcion,
                                'cantidad': int(cantidad),
                                'valor_unitario': valor_total / cantidad if cantidad > 0 else 0,
                                'valor_total': valor_total,
                                'valor_pagado': valor_pagado,
                                'valor_objetado': valor_objetado,
                                'observacion': '',
                                'estado': 'objetado' if valor_objetado > 0 else 'aceptado',
                                'extraction_method': 'multiline'
                            }
        
        # Patrón 4: Procedimiento sin código (como VENDA ELASTICA)
        if re.match(r'^[A-ZÁÉÍÓÚÑ]', line, re.IGNORECASE) and '$' in line:
            # Patrón para línea sin código
            no_code_pattern = r'^([A-ZÁÉÍÓÚÑ][A-ZÁÉÍÓÚÑ\s\w\/\#\,\.\-\(\)\%]+?)\s+(\d+(?:\.\d+)?)\s+\$?([\d,\.]+)\s+\$?([\d,\.]+)\s+\$?([\d,\.]+)'
            match = re.match(no_code_pattern, line, re.IGNORECASE)
            
            if match:
                descripcion = self._clean_description(match.group(1).strip())
                cantidad = float(match.group(2).strip())
                valor_total = self._parse_money_value(match.group(3))
                valor_pagado = self._parse_money_value(match.group(4))
                valor_objetado = self._parse_money_value(match.group(5))
                
                if self._is_valid_procedure_without_code(descripcion, valor_total):
                    return {
                        'codigo': '00000',
                        'descripcion': descripcion,
                        'cantidad': int(cantidad),
                        'valor_unitario': valor_total / cantidad if cantidad > 0 else 0,
                        'valor_total': valor_total,
                        'valor_pagado': valor_pagado,
                        'valor_objetado': valor_objetado,
                        'observacion': '',
                        'estado': 'objetado' if valor_objetado > 0 else 'aceptado',
                        'extraction_method': 'no_code'
                    }
        
        return None

    def _extract_observation_from_lines(self, lines: List[str], start_idx: int, end_idx: int) -> str:
        """
        Extrae observaciones que pueden estar en líneas siguientes
        MEJORADO para capturar mejor las observaciones de glosas
        """
        observation = ""
        
        # Buscar en la misma línea después de los valores
        current_line = lines[start_idx]
        
        # Patrón 1: Observación al final de la línea (después de valores)
        obs_pattern1 = r'\$[\d,\.]+\s+\$[\d,\.]+\s+\$[\d,\.]+\s+(.+)$'
        obs_match = re.search(obs_pattern1, current_line)
        if obs_match:
            observation = obs_match.group(1).strip()
        
        # Patrón 2: Observación con código de error (como 4567 >> texto)
        obs_pattern2 = r'(\d{4})\s*>>\s*(.+?)$'
        obs_match = re.search(obs_pattern2, current_line)
        if obs_match:
            observation = obs_match.group(2).strip()
        
        # Buscar en líneas siguientes
        for i in range(start_idx + 1, min(start_idx + 5, end_idx)):
            if i >= len(lines):
                break
                
            line = lines[i].strip()
            
            # Si encontramos un nuevo procedimiento, parar
            if re.match(r'^\d{5}', line) or 'Total' in line:
                break
            
            # Observación con código
            if re.match(r'^\d{4}\s*>>', line):
                obs_match = re.search(r'^\d{4}\s*>>\s*(.+)', line)
                if obs_match:
                    new_obs = obs_match.group(1).strip()
                    if observation:
                        observation += " " + new_obs
                    else:
                        observation = new_obs
            
            # Continuación de observación (línea que empieza con >>)
            elif re.match(r'^>>', line):
                continuation = line[2:].strip()
                if observation:
                    observation += " " + continuation
                else:
                    observation = continuation
            
            # Texto libre que podría ser observación
            elif line and not re.match(r'^\d', line) and len(line) > 10:
                # Solo si no tenemos observación aún y la línea parece ser texto descriptivo
                if not observation and any(word in line.upper() for word in ['GLOSA', 'OBJETA', 'NO', 'PERTINENTE', 'CORRESPONDE']):
                    observation = line
        
        return self._clean_observation(observation)

    def _extract_procedures_from_full_text(self, text: str) -> List[Dict[str, Any]]:
        """
        Extracción de respaldo cuando no se encuentra tabla estructurada
        """
        procedures = []
        
        # Múltiples patrones para capturar diferentes formatos
        patterns = [
            # Patrón 1: Código 5 dígitos + descripción + valores
            r'(\d{5})\s+([A-ZÁÉÍÓÚÑ][A-ZÁÉÍÓÚÑ\s\w\/\#\,\.\-\(\)\%]+?)\s+(\d+(?:\.\d+)?)\s+\$?([\d,\.]+)\s+\$?([\d,\.]+)\s+\$?([\d,\.]+)',
            # Patrón 2: Código compuesto + descripción + valores
            r'(\d{5,8}-\d{1,2})\s+([A-ZÁÉÍÓÚÑ][A-ZÁÉÍÓÚÑ\s\w\/\#\,\.\-\(\)\%]+?)\s+(\d+(?:\.\d+)?)\s+\$?([\d,\.]+)\s+\$?([\d,\.]+)\s+\$?([\d,\.]+)',
        ]
        
        for pattern in patterns:
            matches = re.finditer(pattern, text, re.MULTILINE | re.IGNORECASE)
            for match in matches:
                try:
                    codigo = match.group(1).strip()
                    descripcion = self._clean_description(match.group(2).strip())
                    cantidad = float(match.group(3).strip())
                    valor_total = self._parse_money_value(match.group(4))
                    valor_pagado = self._parse_money_value(match.group(5))
                    valor_objetado = self._parse_money_value(match.group(6))
                    
                    if self._is_valid_procedure(codigo, descripcion, valor_total):
                        procedure = {
                            'codigo': codigo,
                            'descripcion': descripcion,
                            'cantidad': int(cantidad),
                            'valor_unitario': valor_total / cantidad if cantidad > 0 else 0,
                            'valor_total': valor_total,
                            'valor_pagado': valor_pagado,
                            'valor_objetado': valor_objetado,
                            'observacion': '',
                            'estado': 'objetado' if valor_objetado > 0 else 'aceptado',
                            'extraction_method': 'full_text'
                        }
                        procedures.append(procedure)
                except Exception as e:
                    logger.error(f"Error procesando match: {e}")
                    continue
        
        return procedures

    def _is_valid_procedure(self, codigo: str, descripcion: str, valor_total: float) -> bool:
        """Validación mejorada de procedimientos"""
        # Validar código - aceptar diferentes formatos
        valid_code = (
            re.match(r'^\d{5}$', codigo) or  # 5 dígitos
            re.match(r'^\d{5,8}-\d{1,2}$', codigo) or  # Código compuesto
            codigo == '00000'  # Sin código
        )
        
        if not valid_code:
            return False
        
        # Validar descripción
        if not descripcion or len(descripcion.strip()) < 3:
            return False
        
        # La descripción no debe ser solo observación
        if descripcion.startswith('>>') or re.match(r'^\d{4}\s*>>', descripcion):
            return False
        
        # Patrones inválidos en descripción
        invalid_patterns = [
            'Pagina', 'LIQ-', 'Liquidación de siniestro', 'Fecha de Pago',
            'Víctima :', 'Número de reclamación', 'Póliza :', 'DX :',
            'CORRESPONDE ESTA ESPECIALIDAD', 'Valor de Reclamación',
            'Total', 'SE OBJETA', 'NO PERTINENTE'
        ]
        
        for pattern in invalid_patterns:
            if pattern in descripcion:
                return False
        
        # Validar valor monetario
        if valor_total <= 0 or valor_total > 10000000:
            return False
        
        return True

    def _is_valid_procedure_without_code(self, descripcion: str, valor_total: float) -> bool:
        """Validación específica para procedimientos sin código"""
        # Validar descripción
        if not descripcion or len(descripcion.strip()) < 3:
            return False
        
        # Debe parecer una descripción de procedimiento médico
        medical_keywords = [
            'VENDA', 'CATETER', 'CLORURO', 'SOLUCION', 'INYECTABLE',
            'RADIOGRAFIA', 'CONSULTA', 'EXAMEN', 'PROCEDIMIENTO',
            'MEDICAMENTO', 'SUMINISTRO', 'MATERIAL', 'INSUMO',
            'YESO', 'ALGODON', 'BOLSA', 'ML', 'MG', 'G', 'JERINGA'
        ]
        
        descripcion_upper = descripcion.upper()
        has_medical_keyword = any(keyword in descripcion_upper for keyword in medical_keywords)
        
        if not has_medical_keyword:
            # Si no tiene palabras médicas clave, ser más estricto
            if len(descripcion) < 10:
                return False
        
        # Validar valor monetario
        if valor_total <= 0 or valor_total > 10000000:
            return False
        
        return True

    # ============================================================================
    # NUEVOS MÉTODOS PARA GENERAR CSV EN FORMATO EXCEL
    # ============================================================================

    def generate_excel_format_csv(self, extraction_result: Dict[str, Any]) -> str:
        """
        Genera CSV en el formato del Excel de la IPS
        Orden: NOMBRE PACIENTE, # ID, FACTURA, FECHA FACTURA, VALOR TOTAL GLOSA, 
               CÓDIGO ITEM, DETALLE DE GLOSA, VALOR ITEM, VALOR ACEPTADO, 
               VALOR NO ACEPTADO, RESPUESTA IPS, CLASIFICACIÓN GLOSA, 
               FECHA RECIBIDO GLOSA, DIAS GLOSA, FECHA RADICADO RESPUESTA, 
               DIAS RESPUESTA, CÓDIGO RADICACIÓN, FUNCIONARIO, Entidad,
               DESCRIPCIÓN PROCEDIMIENTO
        """
        import csv
        from io import StringIO
        
        output = StringIO()
        writer = csv.writer(output)
        
        # Headers en el orden exacto del Excel + descripción del procedimiento
        headers = [
            'NOMBRE PACIENTE', '# ID', 'FACTURA', 'FECHA FACTURA', 'VALOR TOTAL GLOSA',
            'CÓDIGO ITEM', 'DETALLE DE GLOSA', 'VALOR ITEM', 'VALOR ACEPTADO', 
            'VALOR NO ACEPTADO', 'RESPUESTA IPS', 'CLASIFICACIÓN GLOSA', 
            'FECHA RECIBIDO GLOSA', 'DIAS GLOSA', 'FECHA RADICADO RESPUESTA', 
            'DIAS RESPUESTA', 'CÓDIGO RADICACIÓN', 'FUNCIONARIO', 'Entidad',
            'DESCRIPCIÓN PROCEDIMIENTO'
        ]
        writer.writerow(headers)
        
        # Extraer información general
        patient_info = extraction_result.get('patient_info', {})
        policy_info = extraction_result.get('policy_info', {})
        financial_summary = extraction_result.get('financial_summary', {})
        procedures = extraction_result.get('procedures', [])
        
        # Información general que se repite para cada procedimiento
        nombre_paciente = patient_info.get('nombre', '')
        id_paciente = patient_info.get('documento', '')
        factura = policy_info.get('numero_reclamacion', '')
        fecha_factura = self._format_date_for_excel(policy_info.get('fecha_siniestro', ''))
        valor_total_glosa = financial_summary.get('total_reclamado', 0)
        fecha_recibido = self._format_date_for_excel(policy_info.get('fecha_pago', ''))
        
        # Si no hay procedimientos, crear una fila con la información general
        if not procedures:
            writer.writerow([
                nombre_paciente, id_paciente, factura, fecha_factura, valor_total_glosa,
                '', '', 0, 0, 0, '', '', fecha_recibido, '', '', '', '', '', '',
                ''  # DESCRIPCIÓN PROCEDIMIENTO vacía
            ])
        else:
            # Crear una fila por cada procedimiento
            for proc in procedures:
                codigo_item = proc.get('codigo', '')
                detalle_glosa = proc.get('observacion', '')
                valor_item = proc.get('valor_total', 0)
                valor_aceptado = proc.get('valor_pagado', 0)
                valor_no_aceptado = proc.get('valor_objetado', 0)
                
                # Campos que quedan vacíos (para completar manualmente por la IPS)
                respuesta_ips = ''
                clasificacion_glosa = ''
                dias_glosa = ''
                fecha_radicado_respuesta = ''
                dias_respuesta = ''
                codigo_radicacion = ''
                funcionario = ''
                entidad = ''
                
                # NUEVO CAMPO SOLICITADO
                descripcion_procedimiento = proc.get('descripcion', '')
                
                writer.writerow([
                    nombre_paciente, id_paciente, factura, fecha_factura, valor_total_glosa,
                    codigo_item, detalle_glosa, valor_item, valor_aceptado, valor_no_aceptado,
                    respuesta_ips, clasificacion_glosa, fecha_recibido, dias_glosa,
                    fecha_radicado_respuesta, dias_respuesta, codigo_radicacion,
                    funcionario, entidad, descripcion_procedimiento
                ])
        
        return output.getvalue()

    def _format_date_for_excel(self, date_str: str) -> str:
        """Formatea fechas para Excel (DD/MM/YYYY)"""
        if not date_str:
            return ''
        
        # Si ya está en formato DD/MM/YYYY, mantenerlo
        if re.match(r'\d{1,2}/\d{1,2}/\d{4}', date_str):
            return date_str
        
        # Convertir otros formatos comunes
        try:
            # Formato YYYY-MM-DD
            if re.match(r'\d{4}-\d{1,2}-\d{1,2}', date_str):
                parts = date_str.split('-')
                return f"{parts[2]}/{parts[1]}/{parts[0]}"
        except:
            pass
        
        return date_str

    # ============================================================================
    # INTEGRACIÓN MEJORADA CON OPENAI
    # ============================================================================

    def _extract_with_openai(self, text: str) -> Dict[str, Any]:
        """Extrae información usando OpenAI GPT con logs detallados"""
        try:
            import openai
            import json
            
            if not self.openai_api_key:
                logger.warning("No se ha configurado API key de OpenAI")
                return self._get_empty_result()
            
            logger.info("=" * 60)
            logger.info("PROCESO OPENAI - INICIO")
            logger.info(f"Timestamp: {datetime.now().isoformat()}")
            start_time = time.time()
            
            # Configurar cliente
            client = openai.OpenAI(api_key=self.openai_api_key)
            logger.info("Cliente OpenAI configurado exitosamente")
            
            # Construir prompt
            prompt = self._build_enhanced_openai_prompt(text)
            logger.info(f"Prompt construido: {len(prompt)} caracteres")
            
            # Preparar request
            messages = [
                {
                    "role": "system",
                    "content": """Eres un experto en análisis de documentos médicos colombianos, especialmente glosas SOAT. 
                    Tu tarea es extraer TODA la información de manera precisa y estructurada.
                    
                    REGLAS CRÍTICAS:
                    1. DEBES encontrar TODOS los procedimientos, sin excepción
                    2. Algunos procedimientos NO tienen código (como VENDA ELASTICA) - usar código "00000"
                    3. Algunos códigos son compuestos (19922562-10)
                    4. Los procedimientos pueden estar en múltiples líneas
                    5. NUNCA omitas procedimientos por no tener código estándar
                    6. Si encuentras el mismo código con diferente descripción, son procedimientos DIFERENTES
                    7. EXTRAE LAS OBSERVACIONES DE GLOSAS - es información crítica"""
                },
                {
                    "role": "user", 
                    "content": prompt
                }
            ]
            
            logger.info("Enviando request a OpenAI API...")
            logger.info(f"Modelo: gpt-4o-mini")
            logger.info(f"Max tokens: 4000")
            logger.info(f"Temperature: 0.1")
            
            # Hacer la llamada
            response = client.chat.completions.create(
                model="gpt-4o-mini",
                messages=messages,
                temperature=0.1,
                max_tokens=4000
            )
            
            elapsed_time = time.time() - start_time
            
            # Log de la respuesta
            logger.info(f"Respuesta recibida en {elapsed_time:.2f} segundos")
            logger.info(f"Tokens usados:")
            logger.info(f"  - Prompt tokens: {response.usage.prompt_tokens}")
            logger.info(f"  - Completion tokens: {response.usage.completion_tokens}")
            logger.info(f"  - Total tokens: {response.usage.total_tokens}")
            
            # Estimar costo (precios aproximados para gpt-4o-mini)
            prompt_cost = response.usage.prompt_tokens * 0.00015 / 1000
            completion_cost = response.usage.completion_tokens * 0.0006 / 1000
            total_cost = prompt_cost + completion_cost
            
            logger.info(f"Costo estimado: ${total_cost:.4f} USD")
            logger.info(f"  - Prompt: ${prompt_cost:.4f}")
            logger.info(f"  - Completion: ${completion_cost:.4f}")
            
            # Procesar respuesta
            ai_response = response.choices[0].message.content.strip()
            logger.info(f"Respuesta recibida: {len(ai_response)} caracteres")
            
            try:
                # Limpiar respuesta
                if '```json' in ai_response:
                    ai_response = ai_response.split('```json')[1].split('```')[0]
                elif '```' in ai_response:
                    ai_response = ai_response.split('```')[1].split('```')[0]
                
                ai_data = json.loads(ai_response)
                
                logger.info("JSON parseado exitosamente")
                logger.info(f"Procedimientos encontrados: {len(ai_data.get('procedures', []))}")
                
                # Log detallado de procedimientos
                if ai_data.get('procedures'):
                    logger.info("Detalle de procedimientos encontrados:")
                    for idx, proc in enumerate(ai_data['procedures'], 1):
                        logger.info(f"  {idx}. Código: {proc.get('codigo', 'N/A')}")
                        logger.info(f"     Descripción: {proc.get('descripcion', 'N/A')}")
                        logger.info(f"     Valor: ${proc.get('valor_total', 0):,.0f}")
                        logger.info(f"     Estado: {proc.get('estado', 'N/A')}")
                        if proc.get('observacion'):
                            logger.info(f"     Observación: {proc.get('observacion', '')[:100]}...")
                
                # Validar y limpiar datos
                ai_data = self._validate_openai_data(ai_data)
                
                logger.info("PROCESO OPENAI - COMPLETADO EXITOSAMENTE")
                logger.info("=" * 60)
                
                return ai_data
                
            except json.JSONDecodeError as e:
                logger.error(f"Error parseando JSON de OpenAI: {e}")
                logger.error(f"Respuesta (primeros 500 chars): {ai_response[:500]}...")
                return self._get_empty_result()
                
        except ImportError:
            logger.error("OpenAI no está instalado. Instale con: pip install openai")
            return self._get_empty_result()
        except Exception as e:
            logger.error(f"Error en proceso OpenAI: {str(e)}", exc_info=True)
            return self._get_empty_result()

    def _build_enhanced_openai_prompt(self, text: str) -> str:
        """Construye prompt mejorado para OpenAI que captura TODOS los procedimientos y observaciones"""
        # Usar más texto para asegurar que capturamos todos los procedimientos
        text_sample = text[:8000] if len(text) > 8000 else text
        
        return f"""
        Analiza este documento de liquidación SOAT colombiano y extrae TODA la información.

        INSTRUCCIONES CRÍTICAS PARA PROCEDIMIENTOS:
        
        1. DEBES encontrar TODOS los procedimientos médicos en la tabla, incluyendo:
           - Procedimientos con código de 5 dígitos (21102, 39145, etc.)
           - Procedimientos con código compuesto (19922562-10)
           - Procedimientos SIN código (VENDA ELASTICA, CATETER INTRAVENOSO, etc.)
           
        2. Para procedimientos sin código, usa "00000" como código
        
        3. IMPORTANTE: En el documento puede aparecer EL MISMO CÓDIGO varias veces con diferente descripción.
           Por ejemplo:
           21102 RADIOGRAFIA DE RODILLA AP LATE
           21102 RADIOGRAFIA DE PIERNA AP Y LAT
           
           Estos son DOS PROCEDIMIENTOS DIFERENTES que debes incluir ambos.
           
        4. Los procedimientos pueden aparecer en diferentes formatos:
           - Todo en una línea: código descripción cantidad valores
           - En múltiples líneas: código en una línea, descripción en otra
           - Sin código: directamente la descripción seguida de valores
           
        5. Busca ESPECÍFICAMENTE en la tabla que tiene columnas como:
           Código | Descripción | Cant | Valor total | Valor pagado | Valor objetado | Observación
           
        6. INCLUYE TODOS los items que aparezcan en esta tabla, sin excepción.

        7. EXTRAE LAS OBSERVACIONES: Las observaciones son CRÍTICAS. Pueden aparecer:
           - Al final de la línea del procedimiento
           - En líneas separadas con formato "4567 >> texto de la observación"
           - Como texto libre después de los valores monetarios
           
        8. Para INFORMACIÓN GENERAL, extrae:
           - Nombre completo del paciente (después de "Víctima :")
           - Número de documento de identidad  
           - Número de reclamación/factura
           - Fechas importantes (siniestro, ingreso, pago)
           - Valores totales de la liquidación

        TEXTO DEL DOCUMENTO:
        {text_sample}

        Responde ÚNICAMENTE con el siguiente JSON (sin texto adicional):

        {{
        "patient_info": {{
            "nombre": "nombre completo del paciente",
            "documento": "número de documento",
            "tipo_documento": "tipo (CC, TI, etc.)"
        }},
        "policy_info": {{
            "numero_liquidacion": "número de liquidación",
            "poliza": "número de póliza", 
            "numero_reclamacion": "número de reclamación",
            "fecha_siniestro": "fecha del siniestro",
            "fecha_ingreso": "fecha de ingreso",
            "fecha_pago": "fecha de pago",
            "orden_pago": "orden de pago"
        }},
        "procedures": [
            {{
            "codigo": "código del procedimiento (5 dígitos, compuesto, o '00000' si no tiene)",
            "descripcion": "descripción COMPLETA del procedimiento/medicamento/material",
            "cantidad": cantidad numérica,
            "valor_total": valor total numérico,
            "valor_pagado": valor pagado numérico,
            "valor_objetado": valor objetado numérico,
            "observacion": "observación/glosa si existe (MUY IMPORTANTE)",
            "estado": "objetado o aceptado",
            "extraction_method": "ai_extraction"
            }}
        ],
        "financial_summary": {{
            "total_reclamado": valor total reclamado,
            "total_objetado": valor total objetado,
            "total_pagado": valor total pagado,
            "valor_nota_credito": valor nota crédito si existe,
            "valor_impuestos": valor impuestos si existe
        }},
        "diagnostics": [
            {{
            "codigo": "código CIE-10",
            "descripcion": "descripción del diagnóstico",
            "tipo": "principal o secundario"
            }}
        ],
        "ips_info": {{
            "nombre": "nombre de la IPS",
            "nit": "NIT si está disponible"
        }}
        }}

        RECUERDA: 
        - Incluir TODOS los procedimientos que aparezcan en la tabla
        - Si el mismo código aparece varias veces, incluir TODAS las ocurrencias
        - Los valores monetarios deben ser números, no strings
        - Si no tiene código, usar "00000"
        - EXTRAE LAS OBSERVACIONES - son críticas para el proceso de glosas
        """

    # ============================================================================
    # MÉTODOS AUXILIARES MEJORADOS
    # ============================================================================

    def _extract_text_from_pdf(self, pdf_path: str) -> str:
        """Extrae texto de PDF usando PyMuPDF"""
        try:
            doc = fitz.open(pdf_path)
            text = ""
            
            for page_num in range(len(doc)):
                page = doc.load_page(page_num)
                page_text = page.get_text()
                text += page_text + "\n"
            
            doc.close()
            return text
            
        except Exception as e:
            logger.error(f"Error extrayendo texto del PDF: {str(e)}")
            return ""

    def _parse_money_value(self, value_str: str) -> float:
        """Convierte string monetario a float"""
        if not value_str:
            return 0.0
        
        try:
            clean_value = re.sub(r'[\$\s]', '', str(value_str))
            
            if ',' in clean_value and clean_value.count(',') == 1:
                parts = clean_value.split(',')
                if len(parts[1]) <= 2:
                    clean_value = clean_value.replace(',', '.')
                else:
                    clean_value = clean_value.replace(',', '')
            else:
                clean_value = clean_value.replace(',', '')
            
            return float(clean_value)
        except (ValueError, TypeError):
            return 0.0

    def _clean_description(self, description: str) -> str:
        """Limpieza de descripción"""
        if not description:
            return ""
        
        # No remover contenido antes de guiones si es parte de la descripción
        # Solo remover si es claramente basura
        description = re.sub(r'^\d+\s*$', '', description)  # Solo números
        description = re.sub(r'\$[\d,\.]+', '', description)  # Valores monetarios
        description = re.sub(r'\s*\d{4}\s+>>', '', description)  # Códigos de observación
        
        # Remover observaciones que se colaron en la descripción
        if '>>' in description:
            description = description.split('>>')[0].strip()
        
        # Remover texto problemático solo si está al inicio
        stop_words_start = ['LIQ-', 'Pagina', 'Liquidación', 'Fecha de', 'Víctima', 'Número de']
        for stop_word in stop_words_start:
            if description.startswith(stop_word):
                return ""
        
        # Normalizar espacios
        description = re.sub(r'\s+', ' ', description.strip())
        
        # No modificar el caso si ya está bien formateado
        if description and not description.isupper():
            return description
        
        # Si está todo en mayúsculas, convertir a título
        if description.isupper():
            words = description.split()
            cleaned_words = []
            for word in words:
                if len(word) <= 3:
                    cleaned_words.append(word)  # Mantener siglas
                else:
                    cleaned_words.append(word.capitalize())
            description = ' '.join(cleaned_words)
        
        return description

    def _clean_observation(self, observation: str) -> str:
        """Limpieza de observación mejorada"""
        if not observation:
            return ""
        
        # Normalizar espacios
        observation = re.sub(r'\s+', ' ', observation.strip())
        
        # Remover caracteres de inicio problemáticos
        observation = re.sub(r'^[>\s]+', '', observation)
        
        # Truncar si es muy largo
        if len(observation) > 500:
            observation = observation[:500] + "..."
        
        return observation

    def _get_cie10_description(self, codigo: str) -> str:
        """Obtiene descripción de códigos CIE-10"""
        cie10_descriptions = {
            'S836': 'Esguince y distensión de otras partes y las no especificadas de la rodilla',
            'S83': 'Luxación, esguince y distensión de articulaciones y ligamentos de la rodilla',
            'S500': 'Contusión superficial del codo',
            'M25': 'Otros trastornos articulares no clasificados en otra parte',
            'S72': 'Fractura del fémur',
            'S82': 'Fractura de la pierna, incluyendo el tobillo',
            'V299': 'Motociclista [cualquier ocupante de un vehículo de motor de tres ruedas] lesionado en otros accidentes de transporte y en los no especificados',
            'V29': 'Motociclista lesionado en otros accidentes de transporte'
        }
        
        for key, desc in cie10_descriptions.items():
            if codigo.startswith(key):
                return desc
        
        return ""

    def _extract_soat_data(self, text: str) -> Dict[str, Any]:
        """Extracción principal de datos SOAT"""
        try:
            result = self._get_empty_result()
            
            result['patient_info'] = self._extract_patient_info(text)
            result['policy_info'] = self._extract_policy_info(text)
            result['procedures'] = self._extract_procedures(text)
            result['financial_summary'] = self._extract_financial_summary(text)
            result['diagnostics'] = self._extract_diagnostics(text)
            result['ips_info'] = self._extract_ips_info(text)
            
            # Calcular estadísticas
            result['extraction_details'] = self._calculate_extraction_stats(result)
            
            return result
            
        except Exception as e:
            logger.error(f"Error en extracción SOAT: {str(e)}")
            return self._get_empty_result()

    def _extract_patient_info(self, text: str) -> Dict[str, Any]:
        """Extrae información del paciente"""
        patient_info = {}
        
        for pattern in self.patient_patterns['nombre']:
            match = re.search(pattern, text, re.IGNORECASE | re.MULTILINE)
            if match:
                nombre = match.group(1).strip()
                nombre = re.sub(r'\s+', ' ', nombre)
                patient_info['nombre'] = nombre.title()
                break
        
        for pattern in self.patient_patterns['documento']:
            match = re.search(pattern, text, re.IGNORECASE)
            if match:
                if len(match.groups()) == 2:
                    patient_info['tipo_documento'] = match.group(1).strip()
                    patient_info['documento'] = match.group(2).strip()
                else:
                    patient_info['documento'] = match.group(1).strip()
                break
        
        if 'tipo_documento' not in patient_info:
            for pattern in self.patient_patterns['tipo_documento']:
                match = re.search(pattern, text, re.IGNORECASE)
                if match:
                    patient_info['tipo_documento'] = match.group(1).strip()
                    break
        
        return patient_info

    def _extract_policy_info(self, text: str) -> Dict[str, Any]:
        """Extrae información de póliza"""
        policy_info = {}
        
        for key, patterns in self.policy_patterns.items():
            for pattern in patterns:
                match = re.search(pattern, text, re.IGNORECASE | re.MULTILINE)
                if match:
                    policy_info[key] = match.group(1).strip()
                    break
        
        return policy_info

    def _extract_financial_summary(self, text: str) -> Dict[str, Any]:
        """Extrae resumen financiero"""
        financial = {}
        
        for key, patterns in self.financial_totals_patterns.items():
            for pattern in patterns:
                match = re.search(pattern, text, re.IGNORECASE | re.MULTILINE)
                if match:
                    financial[key] = self._parse_money_value(match.group(1))
                    break
        
        if 'valor_reclamacion' in financial and 'valor_objetado' in financial:
            financial['total_aceptado'] = financial['valor_reclamacion'] - financial['valor_objetado']
            
            if financial['valor_reclamacion'] > 0:
                financial['porcentaje_objetado'] = (financial['valor_objetado'] / financial['valor_reclamacion']) * 100
            else:
                financial['porcentaje_objetado'] = 0.0
        
        if 'valor_reclamacion' in financial:
            financial['total_reclamado'] = financial['valor_reclamacion']
        if 'valor_objetado' in financial:
            financial['total_objetado'] = financial['valor_objetado']
        if 'valor_pagado' in financial:
            financial['total_pagado'] = financial['valor_pagado']
        
        return financial

    def _extract_diagnostics(self, text: str) -> List[Dict[str, Any]]:
        """Extrae diagnósticos"""
        diagnostics = []
        
        for pattern in self.diagnostic_patterns:
            matches = re.findall(pattern, text, re.IGNORECASE)
            
            for match in matches:
                codigo = match.strip().upper()
                
                diagnostic = {
                    'codigo': codigo,
                    'descripcion': self._get_cie10_description(codigo),
                    'tipo': 'principal' if len(diagnostics) == 0 else 'secundario'
                }
                
                diagnostics.append(diagnostic)
        
        return diagnostics

    def _extract_ips_info(self, text: str) -> Dict[str, Any]:
        """Extrae información de IPS"""
        ips_info = {}
        
        for pattern in self.ips_patterns:
            match = re.search(pattern, text, re.IGNORECASE | re.MULTILINE)
            if match:
                nombre = match.group(1).strip()
                nombre = re.sub(r'\s+', ' ', nombre)
                ips_info['nombre'] = nombre.title()
                break
        
        nit_pattern = r'NIT\s*-?\s*(\d{9,12})'
        match = re.search(nit_pattern, text, re.IGNORECASE)
        if match:
            ips_info['nit'] = match.group(1).strip()
        
        return ips_info

    def _calculate_extraction_stats(self, result: Dict[str, Any]) -> Dict[str, Any]:
        """Calcula estadísticas de extracción"""
        procedures = result.get('procedures', [])
        financial = result.get('financial_summary', {})
        
        stats = {
            'total_procedimientos': len(procedures),
            'procedimientos_objetados': len([p for p in procedures if p.get('valor_objetado', 0) > 0]),
            'campos_extraidos': self._count_extracted_fields(result),
            'calidad_extraccion': self._calculate_extraction_quality(result)
        }
        
        if financial:
            stats.update({
                'total_reclamado': financial.get('total_reclamado', 0),
                'total_objetado': financial.get('total_objetado', 0),
                'total_aceptado': financial.get('total_aceptado', 0)
            })
        
        return stats

    def _count_extracted_fields(self, result: Dict[str, Any]) -> int:
        """Cuenta campos extraídos exitosamente"""
        count = 0
        
        count += len([v for v in result.get('patient_info', {}).values() if v])
        count += len([v for v in result.get('policy_info', {}).values() if v])
        count += len([v for v in result.get('financial_summary', {}).values() if v])
        count += len(result.get('procedures', []))
        count += len(result.get('diagnostics', []))
        
        return count

    def _calculate_extraction_quality(self, result: Dict[str, Any]) -> str:
        """Calcula calidad de extracción"""
        total_fields = self._count_extracted_fields(result)
        
        if total_fields >= 20:
            return 'excelente'
        elif total_fields >= 15:
            return 'buena'
        elif total_fields >= 10:
            return 'regular'
        else:
            return 'baja'

    def _get_empty_result(self) -> Dict[str, Any]:
        """Retorna estructura vacía"""
        return {
            'patient_info': {},
            'policy_info': {},
            'procedures': [],
            'financial_summary': {},
            'diagnostics': [],
            'ips_info': {},
            'extraction_details': {}
        }

    def _get_error_result(self, error_message: str) -> Dict[str, Any]:
        """Retorna resultado de error"""
        result = self._get_empty_result()
        result['error'] = error_message
        result['success'] = False
        result['metadata'] = {
            'extraction_date': datetime.now().isoformat(),
            'success': False
        }
        return result

    def _validate_openai_data(self, data: Dict[str, Any]) -> Dict[str, Any]:
        """Valida y limpia los datos extraídos por OpenAI"""
        # Asegurar que los procedimientos tengan los campos correctos
        if 'procedures' in data:
            for proc in data['procedures']:
                # Asegurar tipos de datos correctos
                proc['cantidad'] = int(proc.get('cantidad', 1))
                proc['valor_total'] = float(proc.get('valor_total', 0))
                proc['valor_pagado'] = float(proc.get('valor_pagado', 0))
                proc['valor_objetado'] = float(proc.get('valor_objetado', 0))
                
                # Calcular valor unitario
                if proc['cantidad'] > 0:
                    proc['valor_unitario'] = proc['valor_total'] / proc['cantidad']
                else:
                    proc['valor_unitario'] = 0
                
                # Determinar estado
                proc['estado'] = 'objetado' if proc['valor_objetado'] > 0 else 'aceptado'
                
                # Asegurar que hay método de extracción
                if 'extraction_method' not in proc:
                    proc['extraction_method'] = 'ai_extraction'
                
                # Limpiar observación
                if 'observacion' in proc:
                    proc['observacion'] = self._clean_observation(proc['observacion'])
        
        # Asegurar tipos numéricos en resumen financiero
        if 'financial_summary' in data:
            for key in ['total_reclamado', 'total_objetado', 'total_pagado', 'valor_nota_credito', 'valor_impuestos']:
                if key in data['financial_summary']:
                    data['financial_summary'][key] = float(data['financial_summary'].get(key, 0))
        
        return data

    def _merge_results(self, ocr_result: Dict[str, Any], ai_result: Dict[str, Any]) -> Dict[str, Any]:
        """Combina resultados de OCR y IA de manera inteligente preservando TODOS los procedimientos"""
        ocr_procedures = ocr_result.get('procedures', [])
        ai_procedures = ai_result.get('procedures', [])
        
        logger.info(f"Combinando resultados: OCR={len(ocr_procedures)} procs, AI={len(ai_procedures)} procs")
        
        # En lugar de usar un mapa simple, crear una lista más específica para evitar colisiones
        merged_procedures = []
        added_count = 0
        updated_count = 0
        
        # Primero, agregar TODOS los procedimientos de OCR
        for ocr_proc in ocr_procedures:
            merged_procedures.append(dict(ocr_proc))  # Copia profunda
        
        # Ahora procesar procedimientos de AI
        for ai_proc in ai_procedures:
            found_exact_match = False
            
            # Buscar coincidencia EXACTA (código + descripción + valores similares)
            for i, merged_proc in enumerate(merged_procedures):
                if (merged_proc['codigo'] == ai_proc['codigo'] and 
                    self._are_exact_same_procedure(merged_proc, ai_proc)):
                    
                    # Actualizar con información más completa de AI
                    if len(ai_proc.get('descripcion', '')) > len(merged_proc.get('descripcion', '')):
                        merged_procedures[i]['descripcion'] = ai_proc['descripcion']
                    
                    if ai_proc.get('observacion') and not merged_proc.get('observacion'):
                        merged_procedures[i]['observacion'] = ai_proc['observacion']
                    
                    found_exact_match = True
                    updated_count += 1
                    logger.debug(f"Actualizado procedimiento existente: {ai_proc['codigo']} - {ai_proc['descripcion'][:30]}")
                    break
            
            # Si NO se encontró coincidencia exacta, es un procedimiento ADICIONAL
            if not found_exact_match:
                merged_procedures.append(ai_proc)
                added_count += 1
                logger.debug(f"Agregado nuevo procedimiento de AI: {ai_proc['codigo']} - {ai_proc['descripcion'][:30]}")
        
        logger.info(f"Merge completado: {len(merged_procedures)} procedimientos totales "
                f"({added_count} agregados, {updated_count} actualizados)")
        
        # Log detallado de todos los procedimientos finales
        logger.info("Procedimientos finales después del merge:")
        for i, proc in enumerate(merged_procedures, 1):
            logger.info(f"  {i:2d}. {proc['codigo']} - {proc['descripcion'][:50]}... (${proc['valor_total']:,.0f})")
        
        # Actualizar el resultado con los procedimientos combinados
        ocr_result['procedures'] = merged_procedures
        
        # Combinar otra información si AI la tiene y OCR no
        for section in ['patient_info', 'policy_info', 'financial_summary', 'ips_info']:
            if section in ai_result and isinstance(ai_result[section], dict):
                if section not in ocr_result or not ocr_result[section]:
                    ocr_result[section] = ai_result[section]
                else:
                    # Combinar campos faltantes
                    if isinstance(ocr_result[section], dict):
                        for key, value in ai_result[section].items():
                            if key not in ocr_result[section] or not ocr_result[section][key]:
                                ocr_result[section][key] = value
        
        # Manejar diagnósticos
        if 'diagnostics' in ai_result and isinstance(ai_result['diagnostics'], list):
            if 'diagnostics' not in ocr_result or not ocr_result['diagnostics']:
                ocr_result['diagnostics'] = ai_result['diagnostics']
        
        return ocr_result

    def _are_exact_same_procedure(self, proc1: Dict[str, Any], proc2: Dict[str, Any]) -> bool:
        """
        Determina si dos procedimientos son EXACTAMENTE el mismo
        Usa criterios más estrictos para evitar fusionar procedimientos diferentes con el mismo código
        """
        # Mismo código es requisito básico
        if proc1['codigo'] != proc2['codigo']:
            return False
        
        # Normalizar descripciones para comparación
        desc1 = proc1.get('descripcion', '').upper().strip()
        desc2 = proc2.get('descripcion', '').upper().strip()
        
        # Si las descripciones son exactamente iguales
        if desc1 == desc2:
            return True
        
        # Si una descripción está completamente contenida en la otra (pero ambas deben ser sustanciales)
        if len(desc1) > 20 and len(desc2) > 20:
            if desc1 in desc2 or desc2 in desc1:
                return True
        
        # Comparar valores monetarios - si son muy diferentes, probablemente son procedimientos distintos
        valor1 = proc1.get('valor_total', 0)
        valor2 = proc2.get('valor_total', 0)
        
        if valor1 > 0 and valor2 > 0:
            # Si los valores difieren en más del 10%, probablemente son diferentes
            diff_percentage = abs(valor1 - valor2) / max(valor1, valor2)
            if diff_percentage > 0.1:
                return False
        
        # Para códigos como 39005 que aparecen múltiples veces, ser muy específico
        # Revisar palabras clave distintivas en las descripciones
        if proc1['codigo'] in ['39005', '39118', '39105']:
            # Buscar palabras clave distintivas
            keywords1 = set(desc1.split())
            keywords2 = set(desc2.split())
            
            # Si comparten menos del 70% de las palabras, son diferentes
            common_words = keywords1 & keywords2
            total_unique_words = keywords1 | keywords2
            
            if len(total_unique_words) > 0:
                similarity = len(common_words) / len(total_unique_words)
                if similarity < 0.7:
                    return False
        
        return True


# Ejemplo de uso
if __name__ == "__main__":
    # Configurar logging
    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
    )
    
    # Crear extractor con API key
    api_key = "tu-api-key-aqui"  # Reemplazar con tu API key real
    extractor = MedicalClaimExtractor(openai_api_key=api_key)
    
    # Procesar PDF
    pdf_path = "path/to/your/pdf.pdf"
    result = extractor.extract_from_pdf(pdf_path, strategy='hybrid')
    
    # Generar CSV en formato Excel
    csv_content = extractor.generate_excel_format_csv(result)
    
    # Mostrar resultados
    print("=== DATOS EXTRAÍDOS ===")
    print(json.dumps(result, indent=2, ensure_ascii=False))
    
    print("\n=== CSV EN FORMATO EXCEL ===")
    print(csv_content)